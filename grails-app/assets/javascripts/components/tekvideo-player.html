<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../bower_components/paper-styles/color.html">

<link rel="import" href="tekvideo-timecode.html">
<link rel="import" href="jquery-dependency.html">
<link rel="import" href="tekvideo-math-field.html">

<script src="popcorn.js"></script>
<script src="underscore.js"></script>
<script src="kas.js"></script>

<dom-module id="tekvideo-player">

<template>
<style is="custom-style">
:host {
    display: block;
}

#player iframe {
    position: absolute;
}

a {
    text-decoration: none;
}

#video-navigation li {
    list-style: none;
    padding-left: 5px;
    border-left: 2px solid #0d87e9;
    margin-left: -25px;
}

#video-navigation ul > li {
    list-style: none;
    padding-left: 5px;
    border-left: 0;
    margin-left: -50px;
}

#parent {
    position: relative;
    width: 100%;
    min-height: 360px;
}

#wrapper {
    z-index: 20;
    position: absolute;
    pointer-events: none;
}

.question {
    pointer-events: all;
}

.question.error {
    background-color: var(--paper-red-300);
}

.question.correct {
    background-color: var(--paper-green-300);
}

tekvideo-math-field {
    background: white;
}

#checkButton {
    width: 100%;
    background-color: var(--paper-blue-500);
    color: white;
}
</style>

<style include="iron-flex"></style>

<div id="player-container" class="layout horizontal">
    <div id="parent" class="flex">
        <div id="wrapper"></div>

        <div id="player"></div>
    </div>

    <div class="layout vertical">
        <ul id="video-navigation" class="flex">
            <template is="dom-repeat" items="{{timeline}}" as="subject" indexAs="subjectIndex">
                <li>
                    <a href="#" id="navitem[[subjectIndex]]" 
                       on-click="_handleNavigationClick">
                        <tekvideo-timecode timecode="{{subject.timecode}}"></tekvideo-timecode>
                        &mdash; {{subject.title}}
                    </a>
                </li>
                <ul>
                    <template is="dom-repeat" items="{{subject.questions}}" as="question">
                        <li>
                            <a href="#" id="navitem[[subjectIndex]][[index]]" 
                               on-click="_handleNavigationClick">
                                <tekvideo-timecode timecode="{{question.timecode}}">
                                </tekvideo-timecode>
                                &mdash; {{question.title}}
                            </a>
                        </li>
                    </template>
                </ul>
            </template>
        </ul>
        <div hidden$="{{disableCheckButton}}">
            <paper-button raised id="checkButton">Tjek svar {{disableCheckButton}}</paper-button>
        </div>
    </div>

</div>

</template>

<script>
(function() {
    var BASELINE_WIDTH = 640; // Wide 360p (Standard on YouTube)
    var BASELINE_HEIGHT = 360;

    Polymer({
        is: 'tekvideo-player',

        _cachedPlayer: null,
        _lastTime: 0,
        _questions: [],

        properties: {
            autoplay: {
                type: Boolean,
                value: true
            },
            timeline: {
                type: Array,
                value: [],
                observer: "_timelineChanged"
            },
            videoId: {
                type: String,
                observer: "_videoChanged"
            },
            isYouTube: {
                type: Boolean,
                value: true,
                observer: "_videoChanged"
            },
            disableCheckButton: {
                type: Boolean,
                value: false
            }
        },
        _timelineChanged: function() {
            this._initQuestions();
        },
        _videoChanged: function() {
            if (this.videoId != null) {
                var self = this;
                var constructor = (this.isYouTube) ? Popcorn.HTMLYouTubeVideoElement : Popcorn.HTMLVimeoVideoElement;
                var wrapper = constructor(this.$.player);
                wrapper.src = (this.isYouTube) ?
                    "http://www.youtube.com/watch?v=" + this.videoId + "&controls=0" :
                    "http://player.vimeo.com/video/" + this.videoId;

                if (this._cachedPlayer != null) {
                    this._cachedPlayer.destroy();
                }

                this._cachedPlayer = Popcorn(wrapper);

                if (this.autoplay) {
                    this._cachedPlayer.play();
                } else {
                    this._cachedPlayer.pause();
                }

                this._cachedPlayer.on("timeupdate", function () {
                    self._handleTimeUpdate();
                });
                this._cachedPlayer.on("seeked", function () {
                    self._handleSeeked();
                });
                this._cachedPlayer.on("play", function () {
                    self._removeAllQuestions()
                });

                // TODO How do we handle size?
                this._cachedPlayer.on("pause", function () {
                    self.fire("analytics", {
                        kind: "PAUSE_VIDEO",
                        video: document.location.href,
                        timecode: self._cachedPlayer.currentTime()
                    }, true);
                });

                setTimeout(function () { self._initializeSize(); }, 500);
                this._initEventHandlers();
            }
        },
        _initializeSize: function() {
            var maxWidth = -1;
            var maxHeight = -1;
            console.log(this.$.player);
            $(this.$.player).children().each(function (index, element) {
                var $element = $(element);
                var height = $element.height();
                var width = $element.width();
                if (width > maxWidth) maxWidth = width;
                if (height > maxHeight) maxHeight = height;
            });
            $(this.$.wrapper).width(maxWidth).height(maxHeight);
            this.scaleHeight = maxHeight / BASELINE_HEIGHT;
            this.scaleWidth = maxWidth / BASELINE_WIDTH;
        },
        _handleSeeked: function() {
            for (var i = this._questions.length - 1; i >= 0; i--) {
                this._questions[i].visible = false;
                this._questions[i].shown = false;
            }
            this._removeAllQuestions();
            this._handleTimeUpdate();
        },
        _handleTimeUpdate: function() {
            var timestamp = this._cachedPlayer.currentTime();

            if (timestamp < this._lastTime) {
                this._lastTime = timestamp; 
                this._handleSeeked();
                return;
            }
            this._lastTime = timestamp;

            for (var i = this._questions.length - 1; i >= 0; i--) {
                var q = this._questions[i];
                if (q.timecode !== Math.round(timestamp) && q.visible) {
                    this._removeAllQuestions();
                    q.visible = false;
                } else if (q.timecode === Math.round(timestamp) && !q.visible && !q.shown) {
                    this._cachedPlayer.pause();
                    q.visible = true;
                    q.shown = true;
                    for (var k = 0; k < q.fields.length; k++) {
                        var field = q.fields[k];
                        this._placeInputField(
                            field.name,
                            field.answer,
                            field.topoffset,
                            field.leftoffset);
                    }
                    var ids = this.getVisibleQuestionID();
                    this.fire("questionShown", {
                        subjectId: ids[0],
                        questionId: ids[1],
                        question: q
                    });
                }
            }
        },
        _initEventHandlers: function() {
            var self = this;
            $(this.$.checkButton).click(function (e) {
                e.preventDefault();
                var questionID = self.getVisibleQuestionID();
                var question = self.getVisibleQuestion();
                for (var i = 0; i < question.fields.length; i++) {
                    var field = question.fields[i];
                    console.log(field);
                    var input = self.$$("#" + field.name);
                    
                    var val = input.value;
                    console.log(val);
                    var $input = $(input);
                    $input.removeClass("correct error");
                    var correct = self._validateAnswer(field, val);
                    if (correct) {
                        $input.addClass("correct");
                    } else {
                        $input.addClass("error");
                    }
                    if (val.length > 0) {
                        self.fire("analytics", {
                            kind: "ANSWER_QUESTION",
                            answer: val,
                            correct: correct,
                            subject: questionID[0],
                            question: questionID[1],
                            field: i
                        });
                    }
                }                
            });
        },
        _handleNavigationClick: function (event) {
            var self = this;
            var item = event.model.question || event.model.subject;
            event.preventDefault();
            var skippedAt = self._cachedPlayer.currentTime();
            self._cachedPlayer.currentTime(item.timecode);
            self.fire("analytics", {
                kind: "SKIP_TO_CONTENT",
                video: document.location.href,
                label: item.title,
                videoTimeCode: self._cachedPlayer.currentTime(),
                skippedAt: skippedAt
            }, true);
        },
        _initQuestions: function() {
            this._questions = [];
            for (var i = this.timeline.length - 1; i >= 0; i--) {
                var item = this.timeline[i];
                this._questions = this._questions.concat(item.questions);
            }

            for (var i = 0; i < this._questions.length; i++) {
                this._questions[i].shown = false;
                this._questions[i].visible = false;
            }
        },
        _placeInputField: function(fieldId, evalFunction, offsetTop, offsetLeft) {
            var self = this;
            $(this.$.wrapper).append(this._createInputField(fieldId));

            if (offsetTop < 0) offsetTop = 0;
            if (offsetLeft < 0) offsetLeft = 0;

            var field = $(this.$$("#" + fieldId));
            console.log("placing input field " + fieldId);
            console.log(field);
            field.css({
                position: "absolute",
                top: (offsetTop * self.scaleHeight) + "px",
                left: (offsetLeft * self.scaleWidth) + "px",
                minWidth: 90 * self.scaleWidth,
                minHeight: 20 * self.scaleHeight,
                zIndex: 10000
            });
        },
        _validateAnswer: function(field, value) {
            var answer = field.answer;
            switch (answer.type) {
                case "expression":
                    var expectedValue = KAS.parse(answer.value);
                    var givenAnswer = KAS.parse(value);
                    var result = KAS.compare(expectedValue.expr, givenAnswer.expr, answer.options);
                    return result.equal;
                case "between":
                    var floatVal = parseFloat(value);
                    return floatVal >= answer.min && floatVal <= answer.max;
                case "equal":
                    if (answer.ignoreCase) {
                        value = value.toLowerCase();
                        answer.value = answer.value.toLowerCase();
                    }
                    return value === answer.value;
                case "in-list":
                    return answer.value.indexOf(value) >= 0;
                case "in-expression-list":
                    var givenAnswer = KAS.parse(value);
                    for (var i = 0; i < answer.value.length; i++) {
                        var expr = KAS.parse(answer.value[i]); // TODO Answer should be cached
                        var result = KAS.compare(expr.expr, givenAnswer.expr, answer.options);
                        if (result.equal) return true;
                    }
                    return false;
                case "custom":
                    // Custom validators are hopefully just a temporary feature, that is never going to be needed.
                    // So much wrong with the following code snippet.
                    if (answer.validator === undefined) {
                        var id = "temp_eval_func";
                        answer.validator = eval("function " + id + "() {" + answer.jsValidator + "\n}" + id + "();");
                    }
                    return answer.validator(value);
            }
        },
        getVisibleQuestionID: function() {
            for (var i = 0; i < this.timeline.length; i++) {
                var item = this.timeline[i];
                for (var j = 0; j < item.questions.length; j++) {
                    var question = item.questions[j];
                    if (question.visible) {
                        return [i, j];
                    }
                }
            }
            return null;
        },
        getVisibleQuestion: function() {
            var id = this.getVisibleQuestionID();
            if (id === null) return null;
            return this.timeline[id[0]].questions[id[1]];
        },
        _hideAllFields: function() {
            for (var i = this._questions.length - 1; i >= 0; i--) {
                this._questions[i].visible = false;
            }
        },
        _removeAllQuestions: function() {
            $(this.$.wrapper).find(".question").remove();
            this._hideAllFields();
        },
        _createInputField: function(id) {
            return '<tekvideo-math-field class="question" id="' + id + '"></tekvideo-math-field>';
        },
        setFieldValues: function(subjectIndex, questionIndex, values) {
            // TODO automatically go to subject
            var fields = this.timeline[subjectIndex].questions[questionIndex].fields;
            if (fields != null) {
                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    var element = this.$$("#" + field.name);
                    element.value = values[i];
                }
            }
        }
    });
})();

</script>
</dom-module>